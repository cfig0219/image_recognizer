<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Classifier</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-data@4.10.0"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { margin-bottom: 20px; }
    </style>
</head>
<body>
    <h1>Planet or Not?</h1>
    <div class="container">
        <h2>1. Select an Image to Predict</h2>
        <input type="file" id="predict-image" accept="image/*">
        <button id="predict-button">Predict</button>
        <p id="prediction-result"></p>
    </div>

    <script>
        let model; // Initializes tensor flow training model
        const predictButton = document.getElementById('predict-button');
        const predictionResult = document.getElementById('prediction-result');
        
        // function to select image file
        async function preprocessImage(file) {
            const imageBitmap = await createImageBitmap(file);
            const tensor = tf.browser.fromPixels(imageBitmap)
                .resizeNearestNeighbor([128, 128]) // Resize to 128x128
                .toFloat()
                .div(tf.scalar(255.0)) // Normalize
                .expandDims();
            return tensor;
        }
        
        
        // Function to fetch training data
        async function fetchTrainingData() {
            const xs = [];
            const ys = [];
    
            // Fetch planet images
            const planetFiles = await fetchImageFiles('Training/planet/');
            for (const file of planetFiles) {
                xs.push(await preprocessImage(file));
                ys.push([1, 0]); // Label for planet
            }
    
            // Fetch not_planet images
            const notPlanetFiles = await fetchImageFiles('Training/not_planet/');
            for (const file of notPlanetFiles) {
                xs.push(await preprocessImage(file));
                ys.push([0, 1]); // Label for not planet
            }
    
            return {
                xs: tf.concat(xs),
                ys: tf.tensor2d(ys),
            };
        }
    
        // Fetch images from a folder
        async function fetchImageFiles(folderPath) {
            const response = await fetch(folderPath); // Fetch directory
            const text = await response.text();
            const imageUrls = extractImagePaths(text, folderPath);
    
            const imagePromises = imageUrls.map(url => fetch(url).then(res => res.blob()));
            return Promise.all(imagePromises);
        }
        
        
        // Extract image file paths from a directory listing (specific to server setup)
        function extractImagePaths(htmlText, folderPath) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlText, 'text/html');
            const links = Array.from(doc.querySelectorAll('a'));
            return links
                .map(link => link.getAttribute('href'))
                .filter(href => href.match(/\.(jpg|jpeg|png|gif)$/i))
                .map(fileName => folderPath + fileName);
        }
    
        async function trainModel() {
            const data = await fetchTrainingData();
            const { xs, ys } = data;
    
            // Define the model
            const model = tf.sequential();
            model.add(tf.layers.conv2d({
                inputShape: [128, 128, 3],
                filters: 16,
                kernelSize: 3,
                activation: 'relu',
            }));
            model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
            model.add(tf.layers.flatten());
            model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 2, activation: 'softmax' }));
    
            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy'],
            });
    
            console.log('Starting training...');
            await model.fit(xs, ys, {
                epochs: 5,
                batchSize: 8,
                callbacks: {
                    onEpochEnd: (epoch, logs) => console.log(`Epoch ${epoch + 1}: loss=${logs.loss}, accuracy=${logs.acc}`),
                },
            });
    
            console.log('Training complete.');
            window.model = model;
    
            xs.dispose();
            ys.dispose();
        }
        
        
        // Button to select image to determine if planet or not
        async function predictImage(file) {
            if (!window.model) {
                alert('Model is not trained. Please train the model first.');
                return;
            }
        
            const tensor = await preprocessImage(file);
            console.log('Tensor shape:', tensor.shape); // Debugging tensor
        
            try {
                const prediction = window.model.predict(tensor); // Ensure model is trained
                const predictionArray = prediction.dataSync();
        
                tensor.dispose();
                prediction.dispose();
        
                predictionResult.textContent = predictionArray[0] > predictionArray[1] ? 'Planet' : 'Not Planet';
            } catch (error) {
                console.error('Prediction error:', error);
                alert('Error during prediction. Please check the input and model.');
            }
        }

        predictButton.addEventListener('click', async () => {
            const file = document.getElementById('predict-image').files[0];
            if (!file) {
                alert('Please select an image to predict.');
                return;
            }
            await predictImage(file);
        });
    
        trainModel();
    </script>
</body>
</html>
